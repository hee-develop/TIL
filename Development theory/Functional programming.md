Date: 2021-03-01 02
---

## Functional programming
함수형 프로그래밍

### 패러다임
패러다임(영어: paradigm)은 어떤 한 시대 사람들의 견해나 사고를 근본적으로 규정하고 있는 테두리로서의 인식의 체계, 또는 사물에 대한 이론적인 틀이나 체계를 의미하는 개념

#### 절차적 언어
절차적(코드를 순차적)으로 문제를 해결하는 프로그래밍 언어. C가 이 분류에 해당됨
코드가 써 있는 순서대로(위에서 아래로) 실행되므로, 실제 처리 순서와 비슷해 디버깅이 용이하다는 장점을 가짐

#### 객체 지향 언어
프로그램을 '객체'라는 기본 단위로 나누어, 이들의 상호작용으로 문제를 해결하는 프로그래밍 언어. C++, Java등 현대 대부분의 언어가 객체 지향 언어에 해당
실제 세계의 물체와 객체를 대응시킬 수 있기 때문(객체는 물체로, 프로퍼티는 물체의 고유값으로, 메소드는 물체의 행동으로)에 절차적 언어에 비해 이해하기가 쉬운 편

#### 명령형 패러다임
프로그램을 작성할 때, 무언가를 **어떻게** 처리하라는 식으로 설계하는 방법.
*어떻게 처리할지*를 정하는 것은 **알고리즘**을 의미. 중요한 것은 *명령*이 최종적으로 무엇을 하고 싶은지에 대한 목표는 명시하지 않는다는 것

#### 선언형 패러다임
프로그램을 작성할 때, 무언가에 **어떤 것**을 해야 하는지를 설명하는 방법.
알고리즘 자체보다, 무엇이 하고싶은지에 대한 **행위의 목표**를 명시

### 함수형 프로그래밍
선언형 패러다임의 하나. 순수하게 함수적인 접근 방법으로 문제를 해결하는 것이 목표
말 그대로 프로그램 코드를 순수 함수로만 구성하는 것이다.
순수한 함수는 수학적 함수를 의미하지만, 컴퓨터 공학의 관점에서의 순수한 함수는 다음과 같은 특징을 갖는다:
- 같은 값이 들어오면 같은 결과를 반환한다
- 함수를 실행함에 있어 외부에 영향을 끼치지 않아야 한다

#### 참조 투명성
프로그램 동작의 변경 없이 관련 값을 대체할 수 있다면, 그 표현식은 참조 상 투명하다고 할 수 있다(출처: [위키백과 참조투명성](https://ko.wikipedia.org/wiki/%EC%B0%B8%EC%A1%B0_%ED%88%AC%EB%AA%85%EC%84%B1)).

아래와 같은 함수는 참조 투명하다고 할 수 있다.
```c
int add(int a, int b) {
  return a + b;
}

int c = add(2, 3);
```
`add(2, 3)`대신 `add(2, 3);`의 결과값 `5`를 넣어도 프로그램에는 아무런 변화가 없다.
너무 당연한 얘기같다.

그러나 아래의 함수는 참조 투명하다고 할 수 없다.
```c
int addAndPrint(int a, int b) {
  printf("%d", a + b);
  return a + b;
}

int c = addAndPrint(2, 3);
```
이번에도 `addAndPrint(2, 3)`대신 `5`를 넣는다고 하자.
프로그램에 아무런 변화가 없을까? 그렇지 않다.

`addAndPrint()`함수는 `printf()`를 부르고 있기 때문에, `addAndPrint(2, 3)`대신 `5`를 넣게 되면 `printf()`가 불리지 않게 된다.
즉 프로그램에 변화가 일어났다.
때문에 위 함수는 참조 투명하다고 할 수 없다.


### 함수형 프로그래밍이 뜨는 이유
- 불변성
  - CPU의 성능 향상이 수직적(코어 성능 향상)이 아닌 수평적(스레드 개수 증가)인 전략을 취하게 됨에 따라, 다중스레드 처리가 중요하게 되었다
  - 다중 스레드 처리에서, 변경 가능한 데이터는 다루기가 굉장히 까다롭다(값을 보장할 수 없기 때문)
  - 함수형 프로그래밍은 값의 불변성을 보장하기 때문에, 이러한 제약에 조금 더 자유롭다
- 테스트와 분석
  - 함수 자체의 부수적인 효과가 없기 때문에, 테스트하기 용이하다
  - 특정 입력에 대해 항상 동일한 입력이 반환된다. 어딘가 문제가 있을 때 함수를 떼어 확인할 수 있으므로 버그 분석이 쉽다

### 함수형 프로그래밍이 뜨기 어려운 이유
- 어렵다
  - 여태까지 써 왔던 대부분의 언어가 명령형 패러다임이었고, 이는 현재도 그렇다.
  - 사고 방식이 종래의 명령형 패러다임과는 다르기 때문에(코드 구조가 다르기 때문에), 이러한 코드를 읽는 데 학습이 필요하다.
  - 시간도 돈도 부족한 대부분의 회사에서, 함수형 프로그래밍으로 쉽게 바꾸는 것은 무척 어렵다.
- 불변성
  - 함수형 프로그래밍은 확실히 불변성을 보장해 주기는 한다.
  - 다만, 값의 불변성은 말 그대로 값이 바뀌지 않는 것을 보장해 주는 것일 뿐이라, 최신 값이라는 보장은 할 수 없다

### 소감
함수형 프로그래밍은 옛날 옛적부터 존재해 왔던 패러다임이지만 최근들어 인기가 부상하고 있다.
'함수형 프로그래밍을 한 번 맛 보면 절대 다시 돌아가지 않을 것이다'라는, 다소 과격한 표현의 찬양글(?)도 있는 걸 보면 인기가 대단하긴 한 것 같다.

주니어의 관점으로 봤을 때, 함수형 프로그래밍은 확실히 독특하고 매력적인 분야이기는 하지만, 그렇다고 해서 OOP, 현재의 주류 방식을 완전히 대체할 만큼 위력적이지는 않다고 판단했다.
패러다임은 어디까지나 방법론, 개념의 영역이며 무엇이 옳고 그른지를 정하는 것이 아니기 때문이다.
예를 들어 객체 단위로 움직이는 분야(UI 등)는 함수형 프로그래밍으로 작성하는 것보다는, 객체 지향 패러다임을 사용해 1:1 매칭해 만드는 것이 빠르고 이해하기도 쉬운 코드를 쓸 수 있다고 생각한다.
따라서 함수형 프로그래밍이 대세가 되기엔 조금 무리가 있어 보인다.


### 참고
- [위키백과 패러다임](https://ko.wikipedia.org/wiki/%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84)
- [명령형 언어와 선언형 언어](https://phobyjun.github.io/2019/09/20/%EB%AA%85%EB%A0%B9%ED%98%95(Imperative)-%EC%96%B8%EC%96%B4%EC%99%80-%EC%84%A0%EC%96%B8%ED%98%95(Declarative)-%EC%96%B8%EC%96%B4.html)
