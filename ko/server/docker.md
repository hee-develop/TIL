# Docker 개념과 사용 방법

`Written: 2021-04-03 04-04 04-05 04-06 04-07 04-08`

## Docker
- Docker는 컨테이너 기반의 오픈소스 가상화 플랫폼.
- 컨테이너는 기존의 가상화(OS가상화나 CPU가상화)에서 발생하는 성능 이슈를 해결하기 위해 만들어진 새로운 형태의 가상화.
  메모리나 CPU같은 자원은 공유하되, 프로세스만 격리시켜 가상화하기 때문에, 기존 가상화에 비해 성능이슈가 덜 하다는 장점이 있음.

## Docker image
- 이미지(docker image)란, 컨테이너를 구동하기 위해 필요한 파일이나 설정 등의 정보가 포함되어 있는 파일. ISO를 생각하면 이해가 쉬울 듯
- 서버 구축을 할 때, 환경변수를 설정하거나, 같은 버전의 라이브러리를 설치하거나 하는 복잡한 작업을 '이미지'라는 파일 안에 집어넣음으로써 불필요한 시간 소비를 줄임.

## Docker image
- 도커는 `레이어`라는 개념을 사용해 이미지를 효율적으로 관리할 수 있게끔 해 줌.
- 예를 들어, `A`라는 이미지와 `B`라는 이미지는 둘 다 `Ubuntu`를 기반으로 만들어진 이미지라고 하면,
  - 어떠한 시스템에서 `A`와 `B`를 사용하려면 `Ubuntu`를 두 번 받아야만 함(`A`와 `B`모두 `UbuntuOS`를 필요로 하기 때문에)
  - 그러나 `레이어`를 사용해 `Ubuntu`레이어를 나누어 두면, `A`를 받을 때 `Ubuntu`를 미리 받아 두었기 때문에 `B`를 받을 땐 `Ubuntu`를 받을 필요가 없음(받을 때 시간적, 공간적으로 절약이 가능).
- 이미지는 `tag`로 편하게 버전을 관리할 수 있음.

## Dockerfile
- `Dockerfile`이란, 이미지를 만들기 위한 일련의 과정을 담은 파일
- 어떤 이미지를 베이스로, 무슨 파일을 복사하고, 패키지를 설치하고.. 등등의 과정이 담겨 있음

## 어디에 쓰는지?
- 규모가 큰 서버 : 다수의 프로세스로 같은 서버를 구동시켜야 할 때 유용하게 사용할 수 있음
  - 특히 수요에 의해 갑작스레 서버를 증설해야 할 필요가 있을 때, 도커라면 같은 이미지로 구동만 시키면 끝이지만, 일반적인 경우 환경변수부터 하나씩 차근차근 설정해 나가야 한다(이 경우 Ansible같은 도구를 사용함).
- 개발 환경 : 각자 다른 OS를 사용해 개발한다던가, 이런저런 이유로 로컬에서 개발이 어려운 경우 유용하게 사용 가능
  - 첫 회사에서 프로덕트 개발을 위해 개발 환경을 구성했는데, 하필 OS 버전이 나만 달라서 환경 구성이 3일(...)이나 걸렸던 경험이 있다

## Docker 명령어

### `docker run`
- `-d`: 백그라운드 모드
- `-p`: 포트 포워딩
- `-v`: 볼륨 마운트
- `-e`: 환경 변수 설정
- `-name`: 컨테이너 이름
- `-rm`: 프로세스 종료 시 컨테이너 자동 제거

```shell
% docker run -d -p 8080:80 \
    -e DATABASE_NAME=db \
    -it \
    -rm
    dockerimg .
```
`dockerimg` 이미지를 기반으로 컨테이너를 실행하되,  
포트는 8080포트를 컨테이너의 내부 80포트에 연결하고,  
환경 변수로 `DATABASE_NAME`을 `db`로 설정하고,  
표준 입력을 받도록 하며,  
프로세스가 종료되면 컨테이너를 제거한다.

### `docker ps`
- 옵션 없음 : 실행중인 컨테이너의 목록을 표시
- `-a`: 종료된 컨테이너도 표시
- `-q`: 컨테이너의 ID만 표시

### `docker log`
`STDOUT`, `STDERR`만을 수집함. 로그는 json파일로 저장되므로, 규모가 큰 서비스는 로그 서비스를 이용하지 않으면 파일이 계속 커지므로 주의.
- `--tail`: 마지막 ~줄만 출력
- `-f`: 실시간 출력

### `docker exec`
컨테이너에 접속하기 위한 명령어. run과 비슷하나 현재 실행중인 컨테이너에 명령을 실행시킨다는 차이점이 있음

## 볼륨
- 컨테이너는 하나의 환경이므로, 컨테이너를 삭제(이미지 업데이트 등을 이유로 삭제하는 경우가 있음)하면 내부에 저장되어 있던 파일도 함께 삭제되어버림
- 때문에 볼륨을 설정해 영구 저장이 필요한 데이터는 컨테이너 외부로 저장할
- `-v [외부저장소]:[컨테이너내부]` 으로 마운트 가능.

## Docker compose
여러 컨테이너를 종합적으로 다뤄야 할 때 사용. 예를 들어, 웹 서버를 하나 만든다고 가정하면,  
DB를 다룰 DB컨테이너와 웹 서버 컨테이너 두 개를 다뤄야 한다. 각각 켜고 끄는 것은 귀찮은 일이므로, `docker compose`를 이용해 간편히 켜고 끄는 등의 행위를 할 수 있게 된다.

## Image build
- Base Image를 이용하면 필요한 라이브러리 등이 처음부터 갖춰진 채로 빌드가 진행되므로, 불필요한 수고를 덜을 수 있다.
- 다만 Base image 역시 Base image(OS)가 존재하고, OS에 따라서는 불필요한 라이브러리 등이 설치되어 있는 경우가 있을 수 있다. 최근엔 Docker image용 OS가 존재해, 이 이미지를 사용하면 이미지 크기를 크게 줄일 수 있다.
- Building은 캐시를 사용하므로, 명령어가 수정되었거나 추가하는 파일이 변경되었을 때 캐시를 갱신한다.
  - `COPY` `ADD`등의 명령어는 외부 파일을 참조하고 있으므로, 이 명령이 참조하는 경로/파일의 내용이 변경되면 캐시를 갱신한다.
  - 캐시가 갱신되면, 그 이후 처리도 모두 갱신된다.

### 캐시 사용
```dockerfile
# ...
COPY . /usr/src/app
WORKDIR /usr/src/app
RUN bundle install
```

위 Dockerfile은, 현재 폴더(`.`)의 데이터가 변경되지 않았다면 캐시를 이용해 해당 작업을 건너뛸 수 있다. 위의 예제에서는 `RUN bundle install`작업이 생략된다.

그러나 현재 폴더 내 무언가 데이터가 갱신되면 `RUN`이 참조하는 파일이 변경되었든 변경되지 않았든(Docker로써는 알 길이 없으므로) `RUN bundle install`작업이 실행되며, 불필요한 재설치가 진행되므로 빌드 시간이 느려진다는 문제가 생길 수 있다.

이러한 문제를 해결하기 위해서는, `COPY`를 신중하게 해야 할 필요가 있다. 예시에서 `COPY .`를 하는 이유는 `RUN bundle install`을 하기 위해서다. `bundle install`은 `Gemfile`과 `Gemfile.lock`을 참조하므로, 처음부터 `COPY .`하는 것이 아니고 패키지 관리 파일만 복사해 두면 불필요한 재설치 시간을 아낄 수 있다.

```dockerfile
COPY Gemfile Gemfile.lock /usr/src/app
WORKDIR /usr/src/app
RUN bundle install
# Gemfile이나 Gemfile.lock이 변경되지 않는 한 RUN bundle install단계는 캐시된 값을 사용한다

COPY . /usr/src/app
```

### 명령어 최적화
프로덕션용 도커파일을 빌드하는 경우, 불필요한 로그나 문서 파일, 개발 시에만 사용하는 라이브러리 등은 설치할 필요가 없다. 패키지 설치 명령어에 대부분 이러한 옵션을 제공하므로, 불필요한 파일은 최대한 설치하지 않는 식으로 빌드하면 속도도 빨라지고 이미지 파일을 줄이는 데 도움이 된다.

또한 명령어를 묶어서 실행하면 레이어 수를 줄이는 데에 도움이 되므로, 비슷한 명령은 되도록 묶어 주는 편이 좋다.
