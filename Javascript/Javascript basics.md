Date: 2021-02-06
---

## Javascript
[JavaScript 재입문하기](https://developer.mozilla.org/ko/docs/A_re-introduction_to_JavaScript) 등으로부터 공부한 내용 중 되새겨둘 필요가 있는 내용을 정리

### `Number`타입은 부동소수점형
- [ECMA표준에 따르면]((https://262.ecma-international.org/6.0/#sec-terms-and-definitions-number-value)), `Number`는 실제로 `double`형(IEEE 754)이다
- 따라서 javascript에는 정수가 없다

마침 얼마 전에 자바스크립트 성능 향상 팁 중 하나로 소수를 정수로 바꾸는 예제가 있었다.
모든 수가 부동소수점 타입이라면 굳이 바꿀 필요가 있을까? 실제로 어떻게 바뀌는지 궁금했기 때문에 간단한 연산으로 소요 시간을 비교해 보았다.
같은 자릿수로 비교하는 것은 무리가 있기 때문에 참고하는 정도로만 사용했다.

(Firefox 86.0에 모바일용 카비레이크 i5으로 작성된 결과이며, 브라우저의 엔진 등에 의해 다른 결과가 나올 수도 있음)

```javascript
const LIMIT = 1_000_000;

let num = 1;
console.time('integer');
for (let i = 0; i < LIMIT; i++, num *= 3);
console.timeEnd('integer');

num = 1.1;
console.time('float');
for (let i = 0; i < LIMIT; i++, num *= 1.12345);
console.timeEnd('float');
```

이 연산의 결과는 다음과 같았다.
| 횟수 | 정수 | 부동소수점 |
| --- | --- | --- |
| 1 | 244ms | 245ms |
| 2 | 243ms | 238ms |
| 3 | 244ms | 242ms |
| 4 | 248ms | 244ms |
| 5 | 2379ms | 2361ms |

\* 5번은 1~4보다 10배 많은 반복문을 거친 결과이다.

예상대로 정수와 부동소수점의 성능 차이가 그다지 않았다.
기본적으로 부동소수점 연산은 정수에 비해 연산이 복잡하므로(적어도 전공공부할 때 배웠던 내용은 그렇다) 자바스크립트의 성능에 어느정도 영향은 있을 듯하다.

### 자바스크립트의 배열은 희소 배열이다
자바스크립트의 배열은 일반적인 배열(밀집 배열, dense array)이 아닌 희소 배열(sparse array)이다.
해쉬 형태로 키(인덱스)-값 구조로 이루어져 있어 배열처럼 빠른 속도로 접근이 가능하다.
때문에 배열이 아니더라도 객체로 배열을 구현하는 것도 가능하다.
다만 객체로 만든 배열(혹은 배열을 객체처럼 사용하는 경우(키 값이 연속적이지 않다거나 0과 자연수가 아닌 키를 사용하는 경우 등))의 경우, 내부적으로 최적화가 이루어지지 않아 상대적으로 배열에 비해 느리다.

구체적으로 어떤 방식으로 접근하고 있는지는 조금 더 조사가 필요해 보이지만..
배열 최적화라는 얘기가 나오는 걸 보면 Java의 ArrayList처럼 미리 메모리를 할당하는 형식으로 구현이 되어 있을지도 모르겠다.

일반 배열과 성질이 다르기 때문에 이런 특이사항이 있다.
- 선언하지 않은 인덱스의 값은 `undefined`이 반환된다
- 배열의 크기를 나타내는 프로퍼티 `length`는 마지막 **인덱스의 값+1**이다
  - 배열 요소의 갯수가 아니다

### `const`는 상수 선언이 아니다
`const`는 상수 선언이 아니고, 재할당이 불가능한 변수이다.
원시 데이터는 재할당이 불가능하므로 상수 취급이 가능하지만, 객체는 포인터로 가리키고 있기 때문에 값을 바꿀 수 있다.

### 비구조화 할당
영어로 **Destructuring assignment**, 일본어로는 **分割代入**
말 그대로 값을 할당할 때 구조를 분해시켜서 넣어주는 문법적 설탕

### 나머지 연산자와 전개 연산자
나머지 연산자는 **rest operator**
전개 연산자는 **spread operator**

`Object.assign`이나 `Array.concat`같은 역할을 하며 간략하게 작성이 가능한 문법적 설탕
배열, 객체를 복사(shallow-copy)할 때 유용하게 사용할 수 있음.

### 계산된 속성 이름
ES6부터 객체 리터럴에서 키를 대괄호(`[]`)로 감쌀 때, 대괄호 내에서 계산된 값을 키로 사용할 수 있다.

```js
const obj = { ['a'+'b']: 1 };
obj.ab; // 1
```

### Symbol
ES6에서 새로 추가된 변경 불가능한 원시 타입의 값.
모든 심볼의 값은 고유하며, 이는 같은 키로 만든 심볼도 그렇다.
```js
const sym1 = Symbol('key');
const sym2 = Symbol('key');
sym1 === sym2; // false
```

루비의 심볼과 같은 느낌인 듯

### 단축 평가
논리곱과 논리합(`&&`, `||`) 연산은 `true` `false`를 반환하는 것이 아니고, 마지막으로 평가된 값을 반환한다.

```js
'apple' && 'banana' // 'banana'
```
`'apple'`을 먼저 평가(`true`)한 뒤 `'banana'`를 평가(`true`)한다. 마지막으로 평가된 값이 `'banana'`이므로, 이를 반환한다.

```js
'apple' || 'banana' // 'apple'
```
`'apple'`을 먼저 평가(`true`)한다. 논리합 연산은 좌항이 `true`라면 우항은 평가하지 않는다.
마지막으로 평가된 값이 `'apple'`이므로, 이를 반환한다.

값이 있을 때만 무언가를 하고자 할 때, `if`문을 쓰지 않고 짧게 쓰는 것이 가능하다.
```js
if (a) a.something(); // a && a.something();
// ES2020의 optional chaining을 사용하면 a?.something(); 처럼 더 줄여쓸 수도 있다.

if (b) b = c; // b && b = c;
```

혹은 React는 조건문 등의 처리는 작성할 수 없기 때문에 단축 평가로 조건문을 대신해 사용할 수 있다.
