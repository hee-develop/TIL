(self.webpackChunk=self.webpackChunk||[]).push([[694],{1982:(e,i,l)=>{"use strict";l.r(i),l.d(i,{data:()=>t});const t={key:"v-23ac14da",path:"/ko/git/study-git.html",title:"Git 공부한 내용 정리",lang:"ko-KR",frontmatter:{},excerpt:"",headers:[{level:2,title:"2021-01-25",slug:"_2021-01-25",children:[{level:3,title:"Git에는 삭제가 없다",slug:"git에는-삭제가-없다",children:[]},{level:3,title:".gitignore의 패턴 규칙",slug:"gitignore의-패턴-규칙",children:[]},{level:3,title:"CLI - diff 명령어",slug:"cli-diff-명령어",children:[]},{level:3,title:"CLI - git rm과 rm",slug:"cli-git-rm과-rm",children:[]},{level:3,title:"CLI - git log의 사용법",slug:"cli-git-log의-사용법",children:[]}]},{level:2,title:"2021-01-26",slug:"_2021-01-26",children:[{level:3,title:"커밋에 변경을 추가",slug:"커밋에-변경을-추가",children:[]},{level:3,title:"Unstage상태로 변경",slug:"unstage상태로-변경",children:[]},{level:3,title:"Git tag",slug:"git-tag",children:[]},{level:3,title:"Git의 동작 원리",slug:"git의-동작-원리",children:[]},{level:3,title:"Branch",slug:"branch",children:[]}]},{level:2,title:"2021-01-27",slug:"_2021-01-27",children:[{level:3,title:"Branch & Merge",slug:"branch-merge",children:[]},{level:3,title:"Remote Branch",slug:"remote-branch",children:[]},{level:3,title:"Rebase",slug:"rebase",children:[]}]}],filePathRelative:"ko/git/study-git.md",git:{updatedTime:1629537148e3,contributors:[]}}},7716:(e,i,l)=>{"use strict";l.r(i),l.d(i,{default:()=>w});var t=l(6252);const a=(0,t.Wm)("h1",{id:"git-공부한-내용-정리",tabindex:"-1"},[(0,t.Wm)("a",{class:"header-anchor",href:"#git-공부한-내용-정리","aria-hidden":"true"},"#"),(0,t.Uk)(" Git 공부한 내용 정리")],-1),r=(0,t.Wm)("p",null,"이미 알고있는 내용은 제외하고 기초부터 탄탄하게 다시 다지기",-1),c=(0,t.Wm)("h2",{id:"_2021-01-25",tabindex:"-1"},[(0,t.Wm)("a",{class:"header-anchor",href:"#_2021-01-25","aria-hidden":"true"},"#"),(0,t.Uk)(" 2021-01-25")],-1),d=(0,t.Uk)("from "),n={href:"https://git-scm.com/book/en/v2",target:"_blank",rel:"noopener noreferrer"},o=(0,t.Uk)("Pro git"),h=(0,t.Uk)(" 1.1 ~ 2.3"),s=(0,t.uE)('<h3 id="git에는-삭제가-없다" tabindex="-1"><a class="header-anchor" href="#git에는-삭제가-없다" aria-hidden="true">#</a> Git에는 삭제가 없다</h3><ul><li>일단 tracking이 시작되면 해당 파일을 삭제하더라도 로그가 남으므로 파일 복구가 가능하다.</li></ul><h3 id="gitignore의-패턴-규칙" tabindex="-1"><a class="header-anchor" href="#gitignore의-패턴-규칙" aria-hidden="true">#</a> <code>.gitignore</code>의 패턴 규칙</h3><ul><li><code>/</code>로 시작하면 <strong>하위 디렉토리에는 적용되지 않는다</strong></li><li><code>/</code>로 끝나면 디렉토리를 의미</li><li><code>!</code>로 시작하면 해당 패턴은 무시하지 않는다</li><li>Glob패턴(쉘의 정규표현식?) 지원</li></ul><h3 id="cli-diff-명령어" tabindex="-1"><a class="header-anchor" href="#cli-diff-명령어" aria-hidden="true">#</a> CLI - diff 명령어</h3><ul><li>diff는 Unstaged상태의 파일만 비교</li><li>Staging Area의 파일을 비교할 때는 <code>--staged</code> 혹은 <code>--cached</code>을 사용한다</li></ul><h3 id="cli-git-rm과-rm" tabindex="-1"><a class="header-anchor" href="#cli-git-rm과-rm" aria-hidden="true">#</a> CLI - <code>git rm</code>과 <code>rm</code></h3><ul><li>실질적으로 삭제되는 (커밋이 추가되는) 것에는 차이가 없음</li><li>파일은 삭제하지 않고 Untracked상태로 변경하고 싶은 경우에는 <code>--cached</code>옵션을 사용한다 <ul><li><code>git rm --cached [something]</code></li><li><code>*</code>이 아니라 <code>\\*</code>을 사용</li></ul></li></ul><h3 id="cli-git-log의-사용법" tabindex="-1"><a class="header-anchor" href="#cli-git-log의-사용법" aria-hidden="true">#</a> CLI - <code>git log</code>의 사용법</h3><ul><li>가장 최근의 커밋부터 순차적으로 표시</li><li>각 커밋의 diff를 볼 때는 <code>-p</code>/<code>--patch</code>옵션을 사용</li><li><code>-2</code>등을 사용하면 최근 두 개만 표시</li><li><code>--graph</code>옵션으로 아스키 그래프를 출력 가능</li><li><code>-S</code>옵션을 사용하면 커밋 내부의 텍스트를 검색</li></ul><h2 id="_2021-01-26" tabindex="-1"><a class="header-anchor" href="#_2021-01-26" aria-hidden="true">#</a> 2021-01-26</h2>',11),g=(0,t.Uk)("from "),u={href:"https://git-scm.com/book/en/v2",target:"_blank",rel:"noopener noreferrer"},m=(0,t.Uk)("Pro git"),b=(0,t.Uk)(" 2.4~"),p=(0,t.uE)('<h3 id="커밋에-변경을-추가" tabindex="-1"><a class="header-anchor" href="#커밋에-변경을-추가" aria-hidden="true">#</a> 커밋에 변경을 추가</h3><ul><li><code>--amend</code>옵션을 사용. 파일 변경 이력과 메시지를 동시에 수정 가능</li><li>커밋을 추가하는 게 아닌 &#39;교체&#39;하는 작업이므로 실질적으로 남는 커밋은 1개뿐</li></ul><h3 id="unstage상태로-변경" tabindex="-1"><a class="header-anchor" href="#unstage상태로-변경" aria-hidden="true">#</a> Unstage상태로 변경</h3><ul><li><code>git reset HEAD &lt;file&gt;</code> : Staged -&gt; Unstaged</li><li><code>git checkout -- &lt;file&gt;</code> : Modified -&gt; Unstaged</li></ul><h3 id="git-tag" tabindex="-1"><a class="header-anchor" href="#git-tag" aria-hidden="true">#</a> Git tag</h3><ul><li><code>git tag -a &lt;version&gt; -m &lt;message&gt;</code></li><li><code>-a</code>옵션이 붙으면 Annotated, 없으면 Lightweight(해당 커밋을 가리키기만 함)</li><li><code>git push origin &lt;tag&gt;</code></li><li><code>git checkout &lt;version&gt;</code>으로 해당 지점으로 이동 가능</li><li>태그로 checkout하는 경우 <code>detached HEAD</code>상태가 되어 기존 커밋들과의 연결이 끊어짐</li><li>따라서 해당 지점으로부터의 fix는 브랜치를 새로 만들어야만 함</li></ul><h3 id="git의-동작-원리" tabindex="-1"><a class="header-anchor" href="#git의-동작-원리" aria-hidden="true">#</a> Git의 동작 원리</h3>',7),f=(0,t.Wm)("li",null,[(0,t.Uk)("1장에서도 나와있듯 Git은 변경사항 기록이 아닌 "),(0,t.Wm)("strong",null,"스냅샷 기록")],-1),k=(0,t.Uk)("스냅샷으로 이정도 용량을 구현할 수 있나? 싶어서 찾아보니 "),v={href:"http://dogfeet.github.io/articles/2012/git-delta.html",target:"_blank",rel:"noopener noreferrer"},W=(0,t.Wm)("strong",null,"실제로는 스냅샷과 델타를 동시에 사용",-1),U=(0,t.Uk)("한다고 한다"),x=(0,t.Wm)("li",null,[(0,t.Uk)("Rebase는 말 그대로 "),(0,t.Wm)("code",null,"base"),(0,t.Uk)("를 한쪽 브랜치로 변경하는 것")],-1),C=(0,t.Wm)("li",null,[(0,t.Uk)("Cherry-pick도 말 그대로 특정 커밋과 해당 커밋의 부모와의 델타를 구해 대상 브랜치에 적용("),(0,t.Wm)("code",null,"cherry-pick"),(0,t.Uk)(")하는 것")],-1),_=(0,t.Wm)("li",null,[(0,t.Uk)("commit하면 파일Blob, 트리 개체, 트리의 root를 가리키는 포인터가 담긴 커밋 객체가 생성됨 "),(0,t.Wm)("img",{src:"https://git-scm.com/book/en/v2/images/commit-and-tree.png",alt:"commit상세"})],-1),A=(0,t.Wm)("h3",{id:"branch",tabindex:"-1"},[(0,t.Wm)("a",{class:"header-anchor",href:"#branch","aria-hidden":"true"},"#"),(0,t.Uk)(" Branch")],-1),G=(0,t.Wm)("ul",null,[(0,t.Wm)("li",null,"가지(branch)로 표현되지만 결국 branch도 포인터에 불과"),(0,t.Wm)("li",null,"commit은 이전 commit을 가리키는 포인터를 포함(단방향)하므로 가지처럼 표현이 가능하게 된다")],-1),B=(0,t.Wm)("h2",{id:"_2021-01-27",tabindex:"-1"},[(0,t.Wm)("a",{class:"header-anchor",href:"#_2021-01-27","aria-hidden":"true"},"#"),(0,t.Uk)(" 2021-01-27")],-1),E=(0,t.Uk)("from "),I={href:"https://git-scm.com/book/en/v2",target:"_blank",rel:"noopener noreferrer"},L=(0,t.Uk)("Pro git"),R=(0,t.Uk)(" 3.1~"),y=(0,t.uE)('<h3 id="branch-merge" tabindex="-1"><a class="header-anchor" href="#branch-merge" aria-hidden="true">#</a> Branch &amp; Merge</h3><ul><li><code>HEAD</code>포인터는 작업 중인 로컬 브랜치를 가리킨다</li><li>부모가 같지만 수정 내용이 다른 두 커밋을 merge할 때 <code>&#39;recursive&#39; strategy</code>로 합쳐지게 된다<br> 이 방식을 3-way merge(target1, parent, target2)라고 한다</li><li>merge되지 않은 브랜치는 <code>git branch --no-merged</code> 명령으로 확인 가능</li></ul><h3 id="remote-branch" tabindex="-1"><a class="header-anchor" href="#remote-branch" aria-hidden="true">#</a> Remote Branch</h3><ul><li><code>fetch</code>는 포인터를 추가하는 것 뿐이므로, 해당 브랜치를 선택해 수정하려면 <code>checkout</code>이 필요하다</li><li><code>git checkout -b &lt;localname&gt; &lt;remotename&gt;</code></li><li>혹은 <code>--track</code>옵션으로 간략하게 쓸 수도 있다. <code>git checkout --track &lt;remotename&gt;</code></li><li><code>git branch -vv</code>로 로컬/리모트 브랜치를 확인할 수 있다</li><li><code>git push &lt;remote&gt; --delete &lt;remoteBranchName&gt;</code>으로 리모트 브랜치를 삭제할 수 있다</li></ul><h3 id="rebase" tabindex="-1"><a class="header-anchor" href="#rebase" aria-hidden="true">#</a> Rebase</h3><ul><li>커밋을 깔끔하게(다수의 지저분한 커밋을 하나로 뭉친다는 의미가 아님) 만들 때 유용</li><li>merge와 달리 <strong>부모 브랜치의 값과 관계 없이, 브랜치의 변경값만 적용할 수 있음</strong></li><li>예시에서는 <code>git rebase --onto &lt;A&gt; &lt;B&gt; &lt;C&gt;</code>. <code>A</code>를 기준으로 <code>B</code>와 <code>C</code>의 공통부모까지의 커밋을 제외할 수 있다</li></ul><p><img src="https://git-scm.com/book/en/v2/images/interesting-rebase-2.png" alt="rebase sub-branch"></p><p><code>client</code>기준으로 <code>C2</code>부터의 변경분은 반영되지 않으므로 <code>C8</code>, <code>C9</code>만 반영됨</p><ul><li>man페이지를 확인해보니 적용 범위를 지정하는 것도 가능한 모양</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>  E---F---G---H---I---J  topicA\n\nthen the command\n\n  git rebase --onto topicA~5 topicA~3 topicA\n\nwould result in the removal of commits F and G:\n\n  E---H&#39;---I&#39;---J&#39;  topicA\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>~5를 기준으로 ~3부터 ~1범위의 커밋을 적용하는 예</p><p>Rebase는 내일 이어서</p>',12),w={render:function(e,i){const l=(0,t.up)("OutboundLink");return(0,t.wg)(),(0,t.j4)(t.HY,null,[a,r,c,(0,t.Wm)("p",null,[d,(0,t.Wm)("a",n,[o,(0,t.Wm)(l)]),h]),s,(0,t.Wm)("p",null,[g,(0,t.Wm)("a",u,[m,(0,t.Wm)(l)]),b]),p,(0,t.Wm)("ul",null,[f,(0,t.Wm)("li",null,[k,(0,t.Wm)("a",v,[W,U,(0,t.Wm)(l)])]),x,C,_]),A,G,B,(0,t.Wm)("p",null,[E,(0,t.Wm)("a",I,[L,(0,t.Wm)(l)]),R]),y],64)}}}}]);