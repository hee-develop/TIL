(self.webpackChunk=self.webpackChunk||[]).push([[3902],{7749:(e,t,s)=>{"use strict";s.r(t),s.d(t,{data:()=>r});const r={key:"v-2ea9cca6",path:"/ko/frontend/react-difference-between-usestate-useref.html",title:"React useState / useRef hooks의 차이",lang:"ko-KR",frontmatter:{},excerpt:"",headers:[{level:3,title:"useState",slug:"usestate",children:[]},{level:3,title:"useRef",slug:"useref",children:[]},{level:3,title:"참고",slug:"참고",children:[]}],filePathRelative:"ko/frontend/react-difference-between-usestate-useref.md",git:{updatedTime:1628002356e3,contributors:[]}}},5919:(e,t,s)=>{"use strict";s.r(t),s.d(t,{default:()=>a});const r=(0,s(6252).uE)('<h1 id="react-usestate-useref-hooks의-차이" tabindex="-1"><a class="header-anchor" href="#react-usestate-useref-hooks의-차이" aria-hidden="true">#</a> React useState / useRef hooks의 차이</h1><p><code>Written: 2021-08-03</code></p><p>함수 컴포넌트는 렌더링 될 때마다 함수 내의 처리를 모두 실행한다. 때문에 함수 내부에 값을 저장하는 것은 hooks을 이용해 다른 곳에 저장해 두어야한다. 기본으로 제공하는 hooks는 여러가지가 있지만 데이터를 저장하는 방법은 크게 <code>useState</code>와 <code>useRef</code>가 있다. React를 처음 쓸 때는 <code>useMemo</code>도 값을 저장하는거라고 생각했는데 Vue의 <code>computed</code>와 비슷한 존재라는 것을 알게 되어 비교 대상에서 제외했다.</p><h3 id="usestate" tabindex="-1"><a class="header-anchor" href="#usestate" aria-hidden="true">#</a> useState</h3><p>말 그대로 <strong>상태</strong>를 가진다. 사용할 때는 <code>getter / setter</code>를 지정하고, 값을 바꿀 때 <code>setter</code>을 불러서 상태를 변경시킬 수 있다. <strong>값의 상태가 변하면 컴포넌트가 이를 감지해 다시 렌더링한다</strong>.</p><h3 id="useref" tabindex="-1"><a class="header-anchor" href="#useref" aria-hidden="true">#</a> useRef</h3><p>말 그대로 <strong>참조</strong>를 가진다. DOM을 가리킬 때 사용하는 <code>ref</code>와 같은 이름이고 실제로 ref를 가리킬 때 사용할 수 있으나 그 <code>ref</code>와는 다른 개념이다. useRef는 가변적인 값을 갖고 있어서 언제든지 수동으로 값을 바꿀 수 있다. useState는 값이 불변(state는 불변값을 가지며 값을 변경할 때 <code>setter</code>를 부른다)하므로 직접 접근해 값을 바꾸어서는 안된다. useRef의 값은 object로 래핑되어 있어서, 값을 참조할 때는 <code>.current</code>로 접근한다. <strong>state와 달리 값이 바뀌어도 컴포넌트는 렌더링을 하지 않는다</strong>.</p><p>input태그의 값을 <code>state</code>로 설정해두면, <strong>input의 값이 바뀔 때마다 컴포넌트가 렌더링된다</strong>. 즉 불필요한 렌더링 과정이 반복되므로 성능에 영향을 미칠 수 있다. 이럴 때 <code>ref</code>로 값을 지정해 두면, input의 값이 바뀌어도 컴포넌트를 재랜더링하지 않으므로 불필요한 연산을 줄일 수 있다.</p><h3 id="참고" tabindex="-1"><a class="header-anchor" href="#참고" aria-hidden="true">#</a> 참고</h3><p>https://www.codebeast.dev/usestate-vs-useref-re-render-or-not/</p>',10),a={render:function(e,t){return r}}}}]);